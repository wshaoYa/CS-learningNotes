# 模拟

题目一般都说了一堆，但感觉按照它说的一步步做就可出答案，只是步骤繁多，但每一步都不是那么难

主要一个你说什么我就按什么做（老实巴交.jpg）

[2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）](https://leetcode.cn/problems/reward-top-k-students/description/)

[2525. 根据规则将箱子分类 - 力扣（LeetCode）](https://leetcode.cn/problems/categorize-box-according-to-criteria/description/)

[2048. 下一个更大的数值平衡数 - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-numerically-balanced-number/description/?envType=daily-question&envId=2023-12-09)

[1599. 经营摩天轮的最大利润 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-profit-of-operating-a-centennial-wheel/description/?envType=daily-question&envId=2024-01-01)

# 枚举

略微有点暴力思想

根据题意，**在允许的时间复杂度情况下，枚举所有可能答案，维护最佳答案**

[100097. 合法分组的最少组数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/description/)

[2048. 下一个更大的数值平衡数 - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-numerically-balanced-number/description/?envType=daily-question&envId=2023-12-09)

[3020. 子集中元素的最大数量 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-maximum-number-of-elements-in-subset/)

[3071. 在矩阵上写出字母 Y 所需的最少操作次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-write-the-letter-y-on-a-grid/description/)

# 滑动窗口

[同向双指针 滑动窗口【基础算法精讲 03】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hd4y1r7Gq/?vd_source=10527fd74695c7dd4ae2589a62aa5f89)

**某些区间长度/区间值是固定的**，通过双指针可滑动维护区间长度/区间值等

涉及双指针的思想

[100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/)

[438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

[1423. 可获得的最大点数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/description/?envType=daily-question&envId=2023-12-03)

# 双指针

一个指针不够指就上两个 ovo

同时维护多个指针变量

涉及两个数在变化，可用两个指针指着这两个变化的东西，从而进行后续的判断等操作

一般**可能**会涉及到先排序的操作

[2938. 区分黑球与白球 - 力扣（LeetCode）](https://leetcode.cn/problems/separate-black-and-white-balls/description/)

[2824. 统计和小于目标的下标对数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-pairs-whose-sum-is-less-than-target/description/)

[2972. 统计移除递增子数组的数目 II - 力扣（LeetCode）](https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/description/)

## 同向双指针

[同向双指针 滑动窗口【基础算法精讲 03】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hd4y1r7Gq/?vd_source=10527fd74695c7dd4ae2589a62aa5f89)

需有一定抽象的单调性）

[2962. 统计最大元素出现至少 K 次的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/count-subarrays-where-max-element-appears-at-least-k-times/description/)

## 相向双指针

## 快慢指针

快慢指针属于一种技巧，通过双指针，一个快（例如每次走两步），一个慢（例如每次走一步），俩指针同时出发，根据题意可达到相关的目的

**常见用途**

- 判断是否有环
- 非提前遍历的情况下 找中间元素

## 前后指针



# 排序

一些值的大小关系顺序很重要，拿到有序的数后能结合贪心等其他思想很好的解决问题，考虑排序

**自定义排序函数**

$golang$中 $slices.SortFunc$函数自定义排序$func$中，$-$减号可抽象理解为小于号，$return \ a-b$ 相当于排序后$a$小于$b$，最终为升序，$b-a$相当于降序~

```go
// 升序
slices.SortFunc(nums, func(a, b int) int {
    return a - b
})
//降序
slices.SortFunc(nums, func(a, b int) int {
    return b - a
})
```

也可用`sort.Slice`函数来自定义排序

```go
//升序
sort.Slice(nums, func(i, j int) bool {
    return nums[i] < nums[j]
})

//降序
sort.Slice(nums, func(i, j int) bool {
    return nums[i] > nums[j]
})
```

[1402. 做菜顺序 - 力扣（LeetCode）](https://leetcode.cn/problems/reducing-dishes/description/)

[2982. 找出出现至少三次的最长特殊子字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii/description/)

[1686. 石子游戏 VI - 力扣（LeetCode）](https://leetcode.cn/problems/stone-game-vi/description/)

## 快速排序



## 归并排序

先分解至最小单位，循环两两结合 进行有序合并

[148. 排序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-list/description/)

### 自顶向下

可dfs递归实现

- 时间 nlogn
- 空间 logn

**模板**

数组上归并排序

```go
// TBD
```

链表上归并排序

```go
// 归并排序-合并
func merge(node1, node2 *ListNode) *ListNode {
	dummy := &ListNode{} // 哑巴节点，方便return
	cur := dummy
	for node1 != nil && node2 != nil {
		if node1.Val <= node2.Val {
			cur.Next = node1
			node1 = node1.Next
		} else {
			cur.Next = node2
			node2 = node2.Next
		}
		cur = cur.Next
	}
	if node1 != nil {
		cur.Next = node1
	} else {
		cur.Next = node2
	}
	return dummy.Next
}

// 归并排序  [head,tail) 抽象意义上的左闭右开
func sort(head, tail *ListNode) *ListNode {
	//边界
	if head == nil {
		return head
	} else if head.Next == tail { // 左闭右开
		head.Next = nil
		return head
	}

	//快慢指针找中间的节点
	slow, fast := head, head
	for fast != tail {
		fast = fast.Next
		if fast == tail {
			break
		}
		fast = fast.Next
		slow = slow.Next
	}
	mid := slow
	return merge(sort(head, mid), sort(mid, tail))
}

func sortList(head *ListNode) *ListNode {
	return sort(head, nil)
}
```

### 自底向上

可迭代枚举subLen子长度进行，

从$1$开始迭代枚举$subLen$子长度，找到**连续的两个**$subLen$长度的数组/链表，进行合并（最后一个数组/链表的长度可小于$subLen$，不碍事，依旧可$merge$合并），$subLen$每次扩大一倍，大于等于$length$则退出

- 时间 nlogn
- 空间 1

**模板**

数组上归并排序

```go
// TBD
```

链表上归并排序

```go
// 归并排序-合并
func merge(node1, node2 *ListNode) *ListNode {
	dummy := &ListNode{} // 哑巴节点，方便return
	cur := dummy
	for node1 != nil && node2 != nil {
		if node1.Val <= node2.Val {
			cur.Next = node1
			node1 = node1.Next
		} else {
			cur.Next = node2
			node2 = node2.Next
		}
		cur = cur.Next
	}
	if node1 != nil {
		cur.Next = node1
	} else {
		cur.Next = node2
	}
	return dummy.Next
}

// 自底向上 归并排序
func sortList(head *ListNode) *ListNode {
	//边界
	if head == nil {
		return nil
	}

	//链表长度
	var length int
	for node := head; node != nil; node = node.Next {
		length++
	}

	//自底向上迭代
	dummy := &ListNode{Next: head}
	for subLen := 1; subLen < length; subLen <<= 1 {
		pre, cur := dummy, dummy.Next
		for cur != nil {
			//第一个subLen
			head1 := cur
			for i := 1; i < subLen && cur.Next != nil; i++ {
				cur = cur.Next
			}

			//第二个subLen
			head2 := cur.Next
			cur.Next = nil // 断开/分解开head1和head2
			cur = head2
			for i := 1; i < subLen && cur != nil && cur.Next != nil; i++ {
				cur = cur.Next
			}

			//下一组head1和head2的开头
			var nxt *ListNode
			if cur != nil {
				nxt = cur.Next
				cur.Next = nil // 断开/分解开head2和nxt
				cur = nxt
			}

			//更新pre  使之前断开的head1和head2拼接起来
			pre.Next = merge(head1, head2)
			for pre.Next != nil {
				pre = pre.Next
			}
		}
	}

	return dummy.Next
}
```

# 二分

**灵神讲解**

- [二分查找 红蓝染色法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)
- [搜索旋转排序数组【基础算法精讲 05】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QK411d76w/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

一般为**【最优解里找可行解】**

**前提**

二分的本质是「**二段性**」而非「**单调性**」！



可手搓二分，也可直接调用语言的默认二分函数（省时省力高效），但有些题目只能（或者说更适合）手搓二分来解题，直接调用二分库/包反而不太好解决

[275. H 指数 II - 力扣（LeetCode）](https://leetcode.cn/problems/h-index-ii/description/?envType=daily-question&envId=2023-10-30)

[2300. 咒语和药水的成功对数 - 力扣（LeetCode）](https://leetcode.cn/problems/successful-pairs-of-spells-and-potions/description/)

[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked)

[2476. 二叉搜索树最近节点查询 - 力扣（LeetCode）](https://leetcode.cn/problems/closest-nodes-queries-in-a-binary-search-tree/description/)

## 手搓二分

可left、right手搓二分（细节把控更好，理解更深刻）

有些题目只能（或者说更适合）手搓二分来解题，直接调用二分库/包反而不太好解决

**可结合【红蓝染色法】帮助理解和编写代码**：[二分查找 红蓝染色法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

手搓二分时，明确【**红色和蓝色的含义**】、【$left$和$right$含义】、【如何转移】、【初始化】、【答案】这几个方面要清晰，很重要，避免逻辑混乱

### 闭区间

**个人理解**：这里区间的含义是，待探索的区间，此处即为$[left,right]$区间内的数还不知道是【红色】还是【蓝色】

- $left$：左侧为【红色】，即$[0 \ , \ left)$均为【红色】
- $right$：右侧为【蓝色】，即$(right \ , \ n)$均为【蓝色】

```go
//初始化
var left, right = 0, n - 1

// 闭区间写法  [left,right]
for left <= right {
    mid := left + (right-left)/2 // 防int溢出
    if xxxx {                    // mid当前及右侧均为【蓝色】，区间更新为[left,mid-1]
        right = mid - 1
    } else { // mid当前及左侧均为【红色】,区间更新为[mid+1,right]
        left = mid + 1
    }
}

//【蓝色】的第一个
return right + 1 //或 return left
```

### 半开半闭区间

这里以$(left,right]$为例，$[left,right)$可同理类推一下

**个人理解**：这里区间的含义是，待探索的区间，此处即为$(left,right]$区间内的数还不知道是【红色】还是【蓝色】

- $left$：当前及左侧为【红色】，即$[0 \ , \ left$]均为【红色】
- $right$：右侧为【蓝色】，即$(right \ , \ n)$均为【蓝色】

```go
//初始化
var left, right = -1, n - 1

// 半开半闭区间  (left,right]
for left < right {
    mid := left + (right-left)/2 // 防int溢出
    if xxxx {                    // mid当前及右侧均为【蓝色】，更新为(left,mid-1]
        right = mid - 1
    } else { // mid当前及左侧均为【红色】,更新为(mid,right]
        left = mid
    }
}

//【蓝色】的第一个
return right + 1 //或 return left + 1
```

### 开区间

（个人较为倾向的写法，较为方便理解）

**个人理解**：这里区间的含义是，待探索的区间，此处即为$(left,right)$区间内的数还不知道是【红色】还是【蓝色】

- $left$：当前及左侧为【红色】，即$[0 \ , \ left]$均为【红色】
- $right$：当前及右侧为【蓝色】，即$[right \ , \ n)$均为【蓝色】

```go
//初始化
var left, right = -1, n

// 开区间写法  (left,right)
for left+1 < right {
    mid := left + (right-left)/2 // 防int溢出
    if xxxx {                    // mid当前及右侧均为【蓝色】,区间更新为（left,mid)
        right = mid
    } else { // mid当前及左侧均为【红色】,区间更新为(mid,right)
        left = mid
    }
}

//【蓝色】的第一个
return right
```

[162. 寻找峰值 - 力扣（LeetCode）](https://leetcode.cn/problems/find-peak-element/description/)

[1901. 寻找峰值 II - 力扣（LeetCode）](https://leetcode.cn/problems/find-a-peak-element-ii/description/)

## 四种大小类型

假如我们通过二分实现了$lowerBound(x)$函数，意为从$nums$数组中找到第一个$>=x$元素的下标

### 求第一个$>=x$元素下标

默认就是大于等于，遂可直接调用$lowerBound(x)$

### 求第一个$>x$元素下标

在整数数组情况下，可使用$lowerBound(x+1)$

### 求最后一个$<x$元素下标

$lowerBound(x)-1$

### 求最后一个$<=x$元素下标

等价于求最后一个$<x+1$元素下标

$lowerBound(x+1)-1$

## 二分答案

将一个复杂的 **优化问题** 转化成一个**可行性 判定问题**, 本质是枚举答案判定可行，不过可行性存在单调性，可二分

正难则反，有时不好正面考虑直接算出最优数值，但能够简单的判断某数值是否合适，且【是否合适】和【数值大小】具有一定的单调性关系时，可考虑二分答案！

优化问题向判定问题转换是关键技巧

对想要求解的ans答案进行二分**【可行解里找最优】**

[1631. 最小体力消耗路径 - 力扣（LeetCode）](https://leetcode.cn/problems/path-with-minimum-effort/description/)

[100200. 标记所有下标的最早秒数 I - 力扣（LeetCode）](https://leetcode.cn/problems/earliest-second-to-mark-indices-i/description/)

# 前缀和

## 一维前缀和

![image-20240203121742854](https://s2.loli.net/2024/02/03/Ddzv91L2EufZTW3.png)

涉及连续子数组问题，可用**前缀和 + 哈希表**来快速判断某子数组是否存在/满足题意要求

[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/description/)

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

[3026. 最大好子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-good-subarray-sum/description/)

## 二维前缀和

[【图解】二维前缀和（附模板代码 Python/Java/C++/Go/JS） - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/UUuRex/)

例如：矩阵上的二维前缀和

```go
type MatrixSum [][]int

func NewMatrixSum(matrix [][]int) MatrixSum {
    m, n := len(matrix), len(matrix[0])
    sum := make([][]int, m+1)
    sum[0] = make([]int, n+1)
    for i, row := range matrix {
        sum[i+1] = make([]int, n+1)
        for j, x := range row {
            sum[i+1][j+1] = sum[i+1][j] + sum[i][j+1] - sum[i][j] + x  // 核心步骤
        }
    }
    return sum
}

// 返回左上角在 (r1,c1) 右下角在 (r2-1,c2-1) 的子矩阵元素和（类似前缀和的左闭右开）
func (s MatrixSum) query(r1, c1, r2, c2 int) int {
    return s[r2][c2] - s[r2][c1] - s[r1][c2] + s[r1][c1]
}

// 如果你不习惯左闭右开，也可以这样写
// 返回左上角在 (r1,c1) 右下角在 (r2,c2) 的子矩阵元素和
func (s MatrixSum) query2(r1, c1, r2, c2 int) int {
    return s[r2+1][c2+1] - s[r2+1][c1] - s[r1][c2+1] + s[r1][c1]
}
```

[3070. 元素和小于等于 k 的子矩阵的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-submatrices-with-top-left-element-and-sum-less-than-k/description/)

# DFS/BFS

[看到递归就晕？带你理解递归的本质！_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1UD4y1Y769/?vd_source=10527fd74695c7dd4ae2589a62aa5f89)

一般是在图/树上进行 深搜和广搜，当然在数组等数据结构上也能进行bfs、dfs

## bfs

[二叉树的层序遍历【基础算法精讲 13】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1hG4y1277i/?spm_id_from=333.999.0.0&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

一层层的搜索，适合层级关系明确的思路

### **模板**

以【二叉树】上bfs为例

- 时间 n
- 空间 n

**两个数组实现bfs**

```go
// 根据题意需要进行自行的修改补充
for len(queue) > 0 {
    var nxt []*TreeNode // 下一层
    for _, cur := range queue {
        if cur.Left != nil {
            nxt = append(nxt, cur.Left)
        }
        if cur.Right != nil {
            nxt = append(nxt, cur.Right)
        }
    }
    queue = nxt
}
```

**队列实现**

```go
// 根据题意需要进行自行的修改补充
queue := []*TreeNode{root}
for len(queue) > 0 {
    for m := len(queue); m > 0; m-- {
        cur := queue[0]   // 当前节点
        queue = queue[1:] // pop

        if cur.Left != nil {
            queue = append(queue, cur.Left)
        }
        if cur.Right != nil {
            queue = append(queue, cur.Right)
        }
    }
}
```

## dfs

递归式的搜索，不到南墙不回头，一路走到底

[765. 情侣牵手 - 力扣（LeetCode）](https://leetcode.cn/problems/couples-holding-hands/solutions/2521878/765-qing-lu-qian-shou-by-wshaoya-5tvc/)

[2477. 到达首都的最少油耗 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/)

[1466. 重新规划路线 - 力扣（LeetCode）](https://leetcode.cn/problems/reorder-routes-to-make-all-paths-lead-to-the-city-zero/description/)

[10033. 使 X 和 Y 相等的最少操作次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-operations-to-make-x-and-y-equal/description/)

[365. 水壶问题 - 力扣（LeetCode）](https://leetcode.cn/problems/water-and-jug-problem/description/?envType=daily-question&envId=2024-01-28)

# 前后缀分解

前缀和后缀数据的计算是**独立不受影响的**

将前缀和后缀分别求解，随后再组合在一起



可能涉及三元组

涉及到前缀和后缀的情况，可将前缀和后缀分开进行分别考虑，逐个击破求解，最后再合一起

[8026. 构造乘积矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-product-matrix/description/)

[100114. 元素和最小的山形三元组 II - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/description/)

[238. 除自身以外数组的乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/product-of-array-except-self/description/)

[2866. 美丽塔 II - 力扣（LeetCode）](https://leetcode.cn/problems/beautiful-towers-ii/description/)

[1671. 得到山形数组的最少删除次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/description/?envType=daily-question&envId=2023-12-22)

# 回溯

一般数据范围较小，可通过暴力枚举等方式计算出答案（但普通的for形式又行不通），可考虑暴力回溯，一般用dfs递归实现

要特别注意正确定义dfs中的参数，否则思路将阻塞尬住

一些难以一眼理解的函数（例如dfs）等，可简单注释下含义，方便code和理解

[2698. 求一个整数的惩罚数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/description/)



## 子集型



## 组合型

[回溯算法套路②组合型回溯+剪枝【基础算法精讲 15】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1xG4y1F7nC/?spm_id_from=333.999.0.0&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

**核心思路**：（两种方式好像都可以）

- 枚举选哪个
- 选 或 不选

一般好像可以进行适当的剪枝，避免一些不必要的操作



## 排列型

[回溯算法套路③排列型回溯+N皇后【基础算法精讲 16】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1mY411D7f6/?vd_source=10527fd74695c7dd4ae2589a62aa5f89)

**核心思路：枚举选哪个**

**代码套路模板**：以【全排列某数】为例

```go
func permute(nums []int) [][]int {
	var (
		n      = len(nums)
		path   = make([]int, n)  // 路径
		onPath = make([]bool, n) // visited  是否已访问过 在路径上
		dfs    func(i int)       // 回溯dfs 每次枚举选哪个 当前该选vals[i]数是几了
		ans    [][]int
	)

	dfs = func(i int) {
		//边界
		if i == n {
			ans = append(ans, append([]int{}, path...)) // 快速copy数组
			return
		}

		//枚举选哪个
		for j, on := range onPath {
			if !on { // 当前未选 可选
				path[i] = nums[j] // 选此数
				onPath[j] = true  // 此数已被占用
				dfs(i + 1)
				onPath[j] = false // 回溯 撤回占用
			}
		}
	}
	dfs(0) // 入口

	return ans
}
```

[46. 全排列 - 力扣（LeetCode）](https://leetcode.cn/problems/permutations/description/)

## 时空复杂度分析

分析回溯问题的时间复杂度，有一个通用公式：**路径长度**×**搜索树的叶子数**

# 贪心

感觉题目有一些贪心巧妙的思路应该存在，按照这种贪心的思路就能很好的避免暴力和繁琐的判断

为了省事省空间时间，从题面整个大的角度去思考问题，直接思考有没有巧妙且贪心的思路酱紫

**证明**：贪心的证明一般比较数学+硬核，一般总体直觉上感觉贪心对即可，对于初级小白来说没必要深究【贪心】的严格证明

[1402. 做菜顺序 - 力扣（LeetCode）](https://leetcode.cn/problems/reducing-dishes/description/)

[1465. 切割后面积最大的蛋糕 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/description/)

[2216. 美化数组的最少删除数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-deletions-to-make-array-beautiful/description/)

[100138. 最大化网格图中正方形空洞的面积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximize-area-of-square-hole-in-grid/solutions/)

[100153. 需要添加的硬币的最小数量 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/solutions/2552290/100153-xu-yao-tian-jia-de-ying-bi-de-zui-keuc/)

[2477. 到达首都的最少油耗 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/description/)

[100151. 使数组成为等数数组的最小代价 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-to-make-array-equalindromic/description/)

[100150. 移除后集合的最多元素数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-size-of-a-set-after-removals/description/)

[2171. 拿出最少数目的魔法豆 - 力扣（LeetCode）](https://leetcode.cn/problems/removing-minimum-number-of-magic-beans/description/?envType=daily-question&envId=2024-01-18)

[670. 最大交换 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-swap/description/?envType=daily-question&envId=2024-01-22)

[1686. 石子游戏 VI - 力扣（LeetCode）](https://leetcode.cn/problems/stone-game-vi/description/)

[2673. 使二叉树所有路径值相等的最小代价 - 力扣（LeetCode）](https://leetcode.cn/problems/make-costs-of-paths-equal-in-a-binary-tree/description/)

# 单调栈

[单调栈【基础算法精讲 26】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1VN411J7S7/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

**思考关键点**

1. 及时去掉无用数据 
2. 优先比较最近元素

[739. 每日温度 - 力扣（LeetCode）](https://leetcode.cn/problems/daily-temperatures/description/)（模板题）

[907. 子数组的最小值之和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-of-subarray-minimums/description/?envType=daily-question&envId=2023-11-27)

[2866. 美丽塔 II - 力扣（LeetCode）](https://leetcode.cn/problems/beautiful-towers-ii/description/)

# 树

## 二叉树

**特殊性质：**最多只有左右两个孩子节点，这一性质非常重要，能够使复杂问题通俗易懂的转换为易理解问题

**一般思路**

- dfs：
  - 形参、返回值、边界条件、入口 的设计要含义明确且正确
- bfs

有时单纯的dfs/bfs不够用，还要一些**数组/变量等额外空间**记录下在dfs/bfs过程中的一些情况，这些额外空间**可以是局部的也可以是全局**的！！

[117. 填充每个节点的下一个右侧节点指针 II - 力扣（LeetCode）](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/description/)

[1038. 从二叉搜索树到更大和树 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search-tree-to-greater-sum-tree/description/)

[101. 对称二叉树 - 力扣（LeetCode）](https://leetcode.cn/problems/symmetric-tree/description/)

[236. 二叉树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/)

### **前序、中序、后序中的两个来构造树**

**注意**：如果只知道前序遍历和后序遍历，这棵二叉树不一定是唯一的，如下图。

<img src="https://pic.leetcode.cn/1705545835-hFQBki-lc889-1.png" alt="lc889-1.png" style="zoom: 33%;" />

- [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)
- [106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)
- [889. 根据前序和后序遍历构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-postorder-traversal/)

## 二叉搜索树（BST）

**性质**

- 左节点值小于自身，右节点值大于自身（左小右大），可在$logn$时间内快速搜索到想要的值。
- 中序遍历后，值为有序

**注意**：BST需尽量往平衡树上靠，不然会退化成链的话时间就会逼近O(n)

### 中序遍历

#### **递归**

```go
func inorderTraversal(root *TreeNode) []int {
	var ans []int
	var dfs func(node *TreeNode)
	dfs = func(node *TreeNode) {
		if node == nil {
			return
		}
		dfs(node.Left)              // 左
		ans = append(ans, node.Val) // 中
		dfs(node.Right)             // 右
	}
	dfs(root)
	return ans
}
```

#### **迭代**

```go
func inorderTraversal(root *TreeNode) []int {
	var (
		st  []*TreeNode
		ans []int
	)
	for root != nil || len(st) > 0 {
		//左
		for root != nil {
			st = append(st, root)
			root = root.Left
		}
		//中
		root, st = st[len(st)-1], st[:len(st)-1]
		ans = append(ans, root.Val)
		//右
		root = root.Right
	}

	return ans
}
```

[240. 搜索二维矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/search-a-2d-matrix-ii/description/?envType=study-plan-v2&envId=top-100-liked)

[230. 二叉搜索树中第K小的元素 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/?envType=study-plan-v2&envId=top-100-liked)

[235. 二叉搜索树的最近公共祖先 - 力扣（LeetCode）](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/?envType=daily-question&envId=2024-02-25)

## 小技巧

**图格式存储的树，进行dfs**

树以图形式存储，进行$dfs$时，可加一个参数$fa$表示当前节点的父节点，方便的避免了向上$dfs$的错误

[2368. 受限条件下可到达节点的数目 - 力扣（LeetCode）](https://leetcode.cn/problems/reachable-nodes-with-restrictions/description/)

[100226. 在带权树网络中统计可连接服务器对数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/)

# 图

## 最小生成树（MST）

### 基本思想

​		n-1条边连通n个点，且总权重最小。

### 切分定理

​		对于两个已连通的点集合，其之间相连的最小边必为整个图最小生成树的一边。

### 常用方法

#### Kruskal（克鲁斯卡尔）

- 取出所有的边，从小到大排序，每次取最小的，若构成环则跳过（利用并查集思想，判断两点是否一个连通分量，如果不是的话union连接此边的两点即可），取n-1条边后结束。
- 时间 O(ElogE) （E为边数，排序需ElogE复杂度）
- 空间 O(V)  （V为点数）

#### **prim（普里姆）**

- 先随机取一点，并维护两个数组：①lowCost 已选取点集合到其他点的最短距离 ②visited 点是否被访问过。不断从visited为false中选出lowCost最小的，直至选出n-1条边结束。
- lowCost一般用最小堆辅助优化，visited有些情况也可不用，直接lowCost也能代替。
- 时间  O(ElogV)  （emm，暂时没搞懂为啥）
- 空间  O(V)

## 单源最短路径

### 基本思想

​		图中，一个点到另外所有点的最短距离

### 常用方法

#### **Dijkstra（迪杰斯特拉）**

![image-20240305142928468](https://s2.loli.net/2024/03/05/YiyAsgUlx5w7hv9.png)

- 维护lowDist数组和visited，记录各点到起点的最短距离，每次选取一个到起点最短的（可最小堆辅助），并更新lowDist，直至遍历完成，思路类似于prim有些。只不过这里的lowDist是各点到**起点**的最短距离。
- 只针对权重非负的，否则贪心思想无法保证下一步选择的路径是最佳的路径（因为负权重的存在
- 时间 O(n²)  
- 空间 O(n²)  

```go
func countPaths(n int, roads [][]int) int {
	var (
		graph   = make([][]int, n)
		lowDist = make([]int, n)  // 从0开始到i 节点的最短距离
		done    = make([]bool, n) // i节点的最短距离lowDist 是否已确定
	)

	//初始化 graph
	for i := 0; i < n; i++ {
		graph[i] = make([]int, n)
		for j := 0; j < n; j++ {
			graph[i][j] = math.MaxInt64 / 2
		}
	}
	for _, r := range roads {
		x, y, d := r[0], r[1], r[2]
		graph[x][y] = d
		graph[y][x] = d
	}

	//初始化dist
	for i := 1; i < n; i++ {
		lowDist[i] = math.MaxInt64 / 2
	}

	//dijkstra
	for {
		x := -1 // 本次选定的节点
		for i := 0; i < n; i++ {
			if !done[i] && (x == -1 || lowDist[i] < lowDist[x]) { // 没确定中的最短dist
				x = i
			}
		}

		if x == -1 { // 所有lowDist都已确定
			break
		}
		done[x] = true

		for y, d := range graph[x] {
			newDist := lowDist[x] + d
			if newDist < lowDist[y] {
				lowDist[y] = newDist
			}
		}
	}
}
```

[1976. 到达目的地的方案数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/description/?envType=daily-question&envId=2024-03-05)

#### **Bellman-Ford**

- 运用dp思想， 待补充 = =

#### **优化的Bellman-Ford—SPFA**

- 维护lowDist数组，记录各点到起点的最短距离，维护Queue队列，每次从队列中取点遍历其边，更新lowDist，若更新则插入队列，另需visited数组记录此点是否已在队列中，防止重复插入队列。队列为空则结束。
- 时间O(V*E)
- 空间O(V)

## 多源最短路径

求图中所有点到其他所有点的最短距离

**常用方法**

### **Floyd （弗洛伊德）**

本质是图的一种动态规划算法

#### **dfs记忆化搜索**

（以下摘抄自灵神题解）

![image-20231115103327168](https://s2.loli.net/2023/11/15/aFGr8lnv2cQNCjf.png)

**模板**

- 时间 $n^3$

- 空间 $n^3$

```go
var (
    g    = make([][]int, n)    // 邻接矩阵 图g
    dfs  func(k, i, j int) int // i和j节点的最短距离 (中途节点编号<=k)
    memo = make([][][]int, n)  // 记忆化搜索
)

// 邻接矩阵 g 初始化
for i := 0; i < n; i++ { // 空间初始化
    g[i] = make([]int, n)
    for j := 0; j < n; j++ {
        g[i][j] = math.MaxInt32 // 代表inf, mathInt32防加法溢出
    }
}
for _, e := range edges { // 根据各题给的edges初始化g
    x, y, w := e[0], e[1], e[2]
    g[x][y], g[y][x] = w, w
}

// 记忆化搜索 空间初始化
for i := 0; i < n; i++ {
    memo[i] = make([][]int, n)
    for j := 0; j < n; j++ {
        memo[i][j] = make([]int, n)
    }
}

// 实现dfs
dfs = func(k, i, j int) int {
    if k < 0 { // 边界
        return g[i][j]
    }
    p := &memo[k][i][j]
    if *p != 0 {
        return *p
    }
    // 状态转移
    res := min(dfs(k-1, i, j), dfs(k-1, i, k)+dfs(k-1, k, j))
    *p = res
    return res
}

// 后续自行使用dfs处理题目
```

#### 递推 dp

(以下同样摘抄自灵神题解)

![image-20231115104513494](https://s2.loli.net/2023/11/15/nXHueJYw32ZMzhC.png)

**模板**

- 时间  $n^3$

- 空间  $n^3$

```go
var a  = make()
var (
    g   = make([][]int, n)     // 邻接矩阵 图g
    dp  = make([][][]int, n+1) //dp[k][i][j] i和j节点的最短距离 (中途节点编号<=k)
)

// 邻接矩阵 g 初始化
for i := 0; i < n; i++ { // 空间初始化
    g[i] = make([]int, n)
    for j := 0; j < n; j++ {
        g[i][j] = math.MaxInt32 // 代表inf, mathInt32防加法溢出
    }
}
for _, e := range edges { // 根据各题给的edges初始化g
    x, y, w := e[0], e[1], e[2]
    g[x][y], g[y][x] = w, w
}

// dp 初始化
for i := 0; i < n+1; i++ { // 注意这里是n+1 因额外的第0层表示边界情况
    dp[i] = make([][]int, n)
    for j := 0; j < n; j++ {
        dp[i][j] = make([]int, n)
    }
}
dp[0] = g // 额外的第0层表示边界情况
for k := 0; k < n; k++ {
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            // 状态转移
            dp[k+1][i][j] = min(dp[k][i][j], dp[k][i][k]+dp[k][k][j])
        }
    }
}

// 后续根据需要调用dp[k][i][j]
```

#### 空间优化 dp

![image-20231115105941822](C:/Users/sw/AppData/Roaming/Typora/typora-user-images/image-20231115105941822.png)

类似滚动数组类型的空间优化，dp循环递推过程中只用到了上一个状态，遂省去一维空间，滚动遍历更新dp。

（正确合理性这里暂时也比较模糊，待后续学习补充qwq）

**模板**

- 时间 $n^3$
- 空间 $n^2$

```go
var (
    g   = make([][]int, n) // 邻接矩阵 图g
    dp  = make([][]int, n) //dp[k][i][j] i和j节点的最短距离 (中途节点编号<=k)
    ans int
)

// 邻接矩阵 g 初始化
for i := 0; i < n; i++ { // 空间初始化
    g[i] = make([]int, n)
    for j := 0; j < n; j++ {
        g[i][j] = math.MaxInt32 // 代表inf, mathInt32防加法溢出
    }
}
for _, e := range edges { // 根据各题给的edges初始化g
    x, y, w := e[0], e[1], e[2]
    g[x][y], g[y][x] = w, w
}

// dp 初始化
for i := 0; i < n; i++ {
    dp[i] = make([]int, n)
}
dp = g // 相较普通dp代码 省去了第一维，遂这里直接初始化dp为g
for k := 0; k < n; k++ {
    for i := 0; i < n; i++ {
        for j := 0; j < n; j++ {
            // 滚动 状态转移
            dp[i][j] = min(dp[i][j], dp[i][k]+dp[k][j])
        }
    }
}
```

[1334. 阈值距离内邻居最少的城市 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/?envType=daily-question&envId=2023-11-14)

[2976. 转换字符串的最小成本 I - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-to-convert-string-i/description/)

## 拓扑排序

### 基本思想

​		图中，某节点进行需入度所有节点均已完成，基于节点进行顺序所排列的一种顺序成为拓扑排序。（关键路径/先修课 思想）

​		只针对于DAG（有向无环图）

### 常见方法

- Kahn算法
  - 维护一个Queue队列和各节点入度，将入度为0节点入队，出队时更新其所指节点的入度-1，为0则插入队列，直至结束。
  - 时间 O(V+E)
  - 空间 O(V+E)

# 记忆化搜索

**递归搜索 + 保存计算结果 = 记忆化搜索**

递归过程中出现重复计算的值，可用额外的哈希表/数组空间存储起来避免重复计算

一般记忆化搜索均能1:1翻译为递推

![image-20240203121949999](https://s2.loli.net/2024/02/03/nXC6T94cLwvY7lz.png)

**启发思路：**

- 选 或 不选
- 枚举选哪个

![image-20231029173156759](https://s2.loli.net/2023/10/29/fLMcOZvnPmVdKgQ.png)

**思考步骤：**

![image-20231029173008419](https://s2.loli.net/2023/10/29/gSZiDKCj79EAINc.png)

**与dp区别：**

- 自顶向下算 = 记忆化搜索
- 自底向上算 = 递推dp

[100107. 使数组变美的最小增量运算数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/description/)

[10033. 使 X 和 Y 相等的最少操作次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-operations-to-make-x-and-y-equal/description/)

[2369. 检查数组是否存在有效划分 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/description/)

# 动态规划

## 基本介绍

普通的算法思路难以着手解决，中间**涉及到许多可能重复计算的方法/值**（一般一眼看上去题目思路无法模拟，较为繁琐多变）

定义状态，用状态给存储进来中间某阶段的值，并根据状态转移方程能计算出所有状态，根据最终的状态可求答案

### **灵感启发**

- 选 或 不选
- 枚举选哪个

![image-20231029173156759](https://s2.loli.net/2023/10/29/fLMcOZvnPmVdKgQ.png)

### **与记忆化搜索区别**

- 自顶向下算 = 记忆化搜索
- 自底向上算 = 递推dp

### **思考步骤**

![image-20231029173008419](https://s2.loli.net/2023/10/29/gSZiDKCj79EAINc.png)

### **大致步骤**

- 定义状态
- 根据定义的状态写出状态转移方程（发现不好写时，可能是自己的状态定义的有问题，可再读题思考状态定义，**或考虑状态升维**！）
- 递推计算出所有状态，求解答案

一般这类题目均可由【递归+记忆化搜索】解决，而【递归+记忆化搜索】均可递推转为dp，dp效率会略高

## 背包问题（套路）

[0-1背包 完全背包【基础算法精讲 18】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16Y411v7Y6/?p=18&spm_id_from=pageDriver&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

![image-20231030121554991](https://s2.loli.net/2023/10/30/9oFmNYDezwCavLK.png)

### 0-1背包

![image-20231030121646656](https://s2.loli.net/2023/10/30/K7CrTwxoWLS9lIQ.png)

#### 常见变形

##### 至多装capacity



##### 恰好装capacity

![image-20231030121909729](https://s2.loli.net/2023/10/30/qVYfeDzdlha8Qg6.png)

最大/最小价值和类似，dfs的+改为max或min即可

##### 至少装capacity



#### 空间优化

##### 滚动数组

![image-20231030122117463](https://s2.loli.net/2023/10/30/km1o4EKZyQPurLq.png)

##### 单个数组

正序不行时，考虑倒序

![image-20231030122246912](https://s2.loli.net/2023/10/30/cgnrS1JXBiW3keA.png)

### 完全背包

![image-20231030122358492](https://s2.loli.net/2023/10/30/yiKP472RAmMFNV5.png)

#### 常见变形

##### 至多装capacity



##### 恰好装capacity

![image-20231030122521551](https://s2.loli.net/2023/10/30/n1KZEPBuJWQUvSs.png)

- 最大价值和：dfs min改为max即可

- 求方案数：min改为两个dfs+即可

##### 至少装capacity



#### 空间优化

类同于0-1背包里所述方法

## 线性DP

线性相关 概念好像是 直来直去 数组类型的DP ？

一般是**相邻的递推**得到，可进行滚动数组空间优化（一般用 两个变量 或 两个一维数组 来维护进行 状态转移）

尽量一题多解，在解线性dp题目时也可写下 【dfs + 记忆化搜索】版本的代码

### **滚动数组优化**

涉及到两个数组时，可用 $i\%2$ 来巧妙的解决操纵哪个数组下标的问题。

### **关键点/题目特征**

- 选或不选
- 枚举选哪个

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/?envType=daily-question&envId=2023-12-10)

[53. 最大子数组和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-subarray/description/)

[2304. 网格中的最小路径代价 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-path-cost-in-a-grid/?envType=daily-question&envId=2023-11-22)

[100133. 购买水果需要的最少金币数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-coins-for-fruits/description/)

[2008. 出租车的最大盈利 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-earnings-from-taxi/description/)

[1671. 得到山形数组的最少删除次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-removals-to-make-mountain-array/description/?envType=daily-question&envId=2023-12-22)

[2707. 字符串中的额外字符 - 力扣（LeetCode）](https://leetcode.cn/problems/extra-characters-in-a-string/description/?envType=daily-question&envId=2024-01-09)

[2369. 检查数组是否存在有效划分 - 力扣（LeetCode）](https://leetcode.cn/problems/check-if-there-is-a-valid-partition-for-the-array/description/)

### 经典套路题目

- 爬楼梯：[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/?envType=daily-question&envId=2023-12-10)
- 最长上升子序列：[300. 最长递增子序列 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-increasing-subsequence/description/)
  - $nlogn$时间，【贪心+二分】做法的模板，利用了dp进阶技巧——交换【状态】和【状态值】

```go
// 求nums最长递增子序列长度
func lengthOfLIS(nums []int) int {
	g := []int{} // g[i]表示长度为i+1的末尾元素最小值
	for _, x := range nums {
		j := sort.SearchInts(g, x) // 二分找到插入位置
		if j == len(g) {           // >=x 的 g[j] 不存在，大于所有数
			g = append(g, x)
		} else { // 替换
			g[j] = x
		}
	}
	return len(g)
}
```



## 树形DP

[树形 DP：树的直径【基础算法精讲 23】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV17o4y187h1/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

[树形 DP：打家劫舍III【基础算法精讲 24】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1vu4y1f7dn/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

[树形DP：监控二叉树【基础算法精讲 25】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1oF411U7qL/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

**题目**

[100118. 在树上执行操作以后得到的最大分数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-score-after-applying-operations-on-a-tree/description/)

### 经典套路题目



## 区间DP



### 经典套路题目

- 最长回文子序列
  <img src="https://s2.loli.net/2023/12/22/e7DWQhMgRA1snSo.png" alt="image-20231222104206831" style="zoom: 80%;" />
- 回文子序列的个数
  <img src="https://s2.loli.net/2023/12/22/Ai6aJSr2mNIuH1z.png" alt="image-20231222104157106" style="zoom: 80%;" />
- 最佳矩阵链求法
  <img src="https://s2.loli.net/2023/12/22/IjeWgTvd6lH97tz.png" alt="image-20231222104132904" style="zoom: 80%;" />

经典的区间$DP$写法，最外层$for$是$Len$长度，内层是左下标$left$。（右下标$right$可由$left+Len$得到）

```go
for L := 1; L < n; L++ {
    for i := 0; i < n-L; i++ {
        l, r := i, i+L                                    // left、right
        // xxx
    }
}
```



当然有时通过观察转移方程，例如某题中的：

$dp[l][r] = max(dp[l+1][r],dp[l][r-1])$

发现其实也可通过倒序遍历$left$，正序遍历$right$方式来进行循环），两种方式均可

```go
for l := n - 1; l >= 0; l-- {
    for r := l + 1; r < n; r++ {
        // xxx
    }
}
```

[1690. 石子游戏 VII - 力扣（LeetCode）](https://leetcode.cn/problems/stone-game-vii/description/?envType=daily-question&envId=2024-02-03)

## 数位DP

[数位 DP 通用模板_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1rS4y1s721/?vd_source=10527fd74695c7dd4ae2589a62aa5f89)



[3007. 价值和小于等于 K 的最大数字 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-number-that-sum-of-the-prices-is-less-than-or-equal-to-k/description/)

## 进阶技巧

交换【状态】和【状态值】（出自：[最长递增子序列【基础算法精讲 20】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1ub411Q7sB/?vd_source=10527fd74695c7dd4ae2589a62aa5f89) ）

## 练习题

[1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/)

[100107. 使数组变美的最小增量运算数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/description/)

# 位运算

**介绍：**位操作（Bit Manipulation）是程序设计中对位模式或二进制数的一元和二元操作。

考虑状态压缩，优化时间和空间

二进制相关

涉及到 异或、与、或、非、左移<<、右移>> 等运算，还有位运算中例如掩码mask等灵活的技巧等

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/description/)

[137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/description/?envType=daily-question&envId=2023-10-15)

[260. 只出现一次的数字 III - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-iii/description/)

[421. 数组中两个数的最大异或值 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/)

[187. 重复的DNA序列 - 力扣（LeetCode）](https://leetcode.cn/problems/repeated-dna-sequences/description/?envType=daily-question&envId=2023-11-05)

[318. 最大单词长度乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-product-of-word-lengths/description/?envType=daily-question&envId=2023-11-06)

[2939. 最大异或乘积 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-xor-product/description/)

[2397. 被列覆盖的最多行数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/?envType=daily-question&envId=2024-01-04)

[100168. 使数组异或和等于 K 的最少操作次数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-operations-to-make-array-xor-equal-to-k/description/)

## **技巧**

灵神总结：[分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/CaOJ45/)

### lowbit

找到某个数的二进制最低位的1

```go
     s = 101100
    ~s = 010011
(~s)+1 = 010100 // 根据补码的定义，这就是 -s   最低 1 左侧取反，右侧不变
s & -s = 000100 // lowbit
```

### 删除最小元素

本质是找并删除【最后一位bit】

```go
s = s&(s-1)

      s = 101100
    s-1 = 101011 // 最低位的 1 变成 0，同时 1 右边的 0 都取反，变成 1
s&(s-1) = 101000
```

### Gosper's Hack

假定当前数（x）的二进制表示中1的数目为oneCnt，通过O(1)时间即找到下一个（升序）有oneCnt个1的数，避免中间的无用枚举

**例如**：初始x=101110，下一个（升序）有4个1的数即为 110011  

```go
var x int = 0
lowBit := x & (-x)              // 找到二进制最低位的1
left := x + lowBit                // 将最后一个01变为10
right := (x ^ left) / lowBit >> 2 // 将原数中01变10前 01右边的所有的1挪至最右侧
x = left | right                  // 拼接下左右部分
```

[2397. 被列覆盖的最多行数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-rows-covered-by-columns/description/?envType=daily-question&envId=2024-01-04)

# 基本数据结构

## 哈希表

**核心观念：**空间换时间

已经算过/遍历过的数存起来，后面再用到时直接上哈希表里根据key取

如果后面的数需要用到前面的东西，而返回去再看前面东西时费劲，就可考虑哈希表

**优化点**：数目少到一定程度时，原先用哈希表维护的值就可直接开个小常量的数组来维护，时空效率更高一些

**经验细节点**：

- 哈希表的val可以是struct结构体，以存储更多的信息。（最好是*指针形式的，方便修改和访问）

[1726. 同积元组 - 力扣（LeetCode）](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)

[2342. 数位和相等数对的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/max-sum-of-a-pair-with-equal-sum-of-digits/description/)

[2661. 找出叠涂元素 - 力扣（LeetCode）](https://leetcode.cn/problems/first-completely-painted-row-or-column/solutions/2549100/2661-zhao-chu-die-tu-yuan-su-by-wshaoya-v36t/)

[2808. 使循环数组所有元素相等的最少秒数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-seconds-to-equalize-a-circular-array/description/)

## 字符串

涉及到较为不简单的字符串系列操作）

[1410. HTML 实体解析器 - 力扣（LeetCode）](https://leetcode.cn/problems/html-entity-parser/description/?envType=daily-question&envId=2023-11-23)

### KMP

高效的字符匹配扫描算法

**灵神讲解博客**

[灵神讲解KMP算法]([(7 封私信 / 80 条消息) 如何更好地理解和掌握 KMP 算法? - 知乎 (zhihu.com)](https://www.zhihu.com/question/21923021/answer/37475572))

**用途**

- 找字符串`text`中**是否存在**另一字符串`pattern`
- 找字符串`text`中子字符串`pattern`**首次出现的下标**
- 找字符串`text`中另一字符串`pattern`**出现的下标列表**

**模板**

- 时间 $n+m$ ($n$为$text$长度，$m$为$pattern$长度)
- 空间 $m$

```go []
// 返回text中pattern出现的下标列表
func kmp(text, pattern string) (ans []int) {
	var (
		m        = len(pattern)
		matchLen = make([]int, m) // [0,i]字符串，前后缀相同的最大长度
		cnt      int
	)

	// 初始化 matchLen
	// cnt 此处含义为 前后缀相同长度
	for i := 1; i < m; i++ {
		v := pattern[i]                    // 后缀末尾字符
		for cnt > 0 && pattern[cnt] != v { //前缀末尾 不等于 后缀末尾
			cnt = matchLen[cnt-1] // 更新为次大前后缀相同长度
		}
		if pattern[cnt] == v { //前缀末尾 等于 后缀末尾
			cnt++
		}
		matchLen[i] = cnt // 更新[0,i]字符串，前后缀相同的最大长度
	}

	//查找text内pattern出现的所有下标，整个流程类同于初始化 matchLen
	cnt = 0 // 此处含义为 text和pattern前缀相同数目
	for i, v := range text {
		for cnt > 0 && pattern[cnt] != byte(v) {
			cnt = matchLen[cnt-1]
		}
		if pattern[cnt] == byte(v) {
			cnt++
		}
		if cnt == m {
			ans = append(ans, i-m+1)
			cnt = matchLen[cnt-1]
		}
	}

	return
}
```

[3008. 找出数组中的美丽下标 II - 力扣（LeetCode）](https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-ii/description/)

[3006. 找出数组中的美丽下标 I - 力扣（LeetCode）](https://leetcode.cn/problems/find-beautiful-indices-in-the-given-array-i/description/)

## 链表

[138. 随机链表的复制 - 力扣（LeetCode）](https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked)

### 删除节点

[删除链表重复节点【基础算法精讲 08】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1VP4y1Q71e/?vd_source=10527fd74695c7dd4ae2589a62aa5f89)

在删除链表节点的题目中，若涉及到可能删除头节点，则最好引入一个哨兵节点（$dummy  \ node$）的$next$来指向$head$，方便最后$return$头结点（$dummy.next$)，简化并优雅化代码

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

[82. 删除排序链表中的重复元素 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/description/?envType=daily-question&envId=2024-01-15)

### 双向链表

`golang`里有自带的库`list`实现双向链表 ovo

[146. LRU 缓存 - 力扣（LeetCode）](https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked)

## 栈

先进后出

在`golang`中一般直接用切片`slice`构建栈，`push`压栈用`append`实现，`pop`出栈用切片表达式`st[:len(st)-1]`来实现

[590. N 叉树的后序遍历 - 力扣（LeetCode）](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/solutions/2645811/590-n-cha-shu-de-hou-xu-bian-li-dfsdie-d-xt3a/)

## 队列

### 普通队列



### 单调队列

队列中的数值在某些层面上具有单调性的特性

[单调队列 滑动窗口最大值【基础算法精讲 27】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1bM411X72E/?vd_source=10527fd74695c7dd4ae2589a62aa5f89)

### 双端队列

两头都可出进的队列，实际过程中可用双向链表模拟好像？

`golang`中可用`list`标准库中的双向链表模拟双端队列

[1670. 设计前中后队列 - 力扣（LeetCode）](https://leetcode.cn/problems/design-front-middle-back-queue/description/)

# 高级数据结构

## 堆/优先队列

涉及到快速取某组数中的最大/最小值时，可考虑堆

### 模板

根据heap接口自行构造实现

```go
// heap.go 接口
type Interface interface {
	sort.Interface
	Push(x any) // add x as element Len()
	Pop() any   // remove and return element Len() - 1.
}
```

Golang中自己构造heap时，$sort.IntSlice$ 很方便的帮我们解决了$Len$、$Swap$、和$Less$函数，只不过它默认用的$Less$不符合我们最大堆，如果想要最小堆的话就不用自己再重写一遍$Less$了

```go
// sort.IntSlice

// IntSlice将Interface的方法附加到[]int，按递增顺序排序
type IntSlice []int

func (x IntSlice) Len() int           { return len(x) }
func (x IntSlice) Less(i, j int) bool { return x[i] < x[j] }
func (x IntSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
```

**示例：最大堆**

想要修改堆顶元素，可直接操纵$IntSlice$（即堆化时的切片数组）的第一个元素，而后调用$Fix$调整堆位置

调用pop和push时需以heap库开头调用，不能直接调用h的pop和push！

```go
type hp struct {
	sort.IntSlice
}

//最大堆。如果想要最小堆则无需重写Less
func (h hp) Less(i, j int) bool {
	return h.IntSlice[i] > h.IntSlice[j]
}

func (h *hp) Push(x any) {
	h.IntSlice = append(h.IntSlice, x.(int))
}

func (h *hp) Pop() any { // heap库内部实现为 将堆顶元素放到数组末尾表示抛弃 数组长度减1
	a := h.IntSlice
	v := a[len(a)-1]
	h.IntSlice = a[:len(a)-1]
	return v
}

h = &hp{nums} // 初始化结构体（nums为切片类型）
heap.Init(h) // 堆化

heap.Fix(h, 0) // 改变堆顶元素后调用Fix，相当于pop & push

heap.Pop(h) // pop
heap.Push(h, 999) // push
```

[2530. 执行 K 次操作后的最大分数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-score-after-applying-k-operations/description/)

[2558. 从数量最多的堆取走礼物 - 力扣（LeetCode）](https://leetcode.cn/problems/take-gifts-from-the-richest-pile/description/)

[1962. 移除石子使总数最小 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-stones-to-minimize-the-total/description/?envType=daily-question&envId=2023-12-23)

[100232. 超过阈值的最少操作数 II - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-operations-to-exceed-threshold-value-ii/description/)

## 并查集

### **基本思想**

​		通常用于解决图中连通、连通分量问题，通过find找到节点的父节点，union连接两节点来实现

- **find路径压缩优化**：
  - 调用find找到x的根节点后，将递归遍历过程中的各个节点的root[x]父节点值改为根节点，下次再find时更快
- **union按秩合并优化**：
  - 不合适的union会导致最终树/图变成一条链，效率低。记录各节点的高度，合并时将根节点高度高的根节点变为高度低的根节点的父节点即可（简单来说就是，低树的根节点挂到高树根节点的下边）。这样整个树有点avl那味，不至于最终树变为一条链。

### 模板

```go
type UnionFind struct {
	root   []int
	height []int
}

// 初始化对象
func NewUnionFind(n int) *UnionFind {
	root := make([]int, n)
	height := make([]int, n)
	for i := 0; i < n; i++ {
		root[i] = i
		height[i] = 1
	}
	return &UnionFind{
		root:   root,
		height: height,
	}
}

// 路径压缩
func (u *UnionFind) Find(x int) int {
	if u.root[x] != x {
		u.root[x] = u.Find(u.root[x])
	}
	return u.root[x]
}

// 按秩优化
func (u *UnionFind) Union(x, y int) {
	rx, ry := u.Find(x), u.Find(y)
	if rx == ry {
		return
	}

	if u.height[rx] >= u.height[ry] {
		u.root[ry] = rx
		u.height[rx] = max(u.height[rx], u.height[ry]+1)
	} else {
		u.root[rx] = ry
	}
}

// 判断连通性
func (u *UnionFind) Connected(x, y int) bool {
	return u.Find(x) == u.Find(y)
}
```

### 复杂度

![image-20220804173128448](https://s2.loli.net/2023/10/21/ixEpulHzXbF6VsK.png)

- 空间复杂度：O(n)

[765. 情侣牵手 - 力扣（LeetCode）](https://leetcode.cn/problems/couples-holding-hands/solutions/2521878/765-qing-lu-qian-shou-by-wshaoya-5tvc/)

[1631. 最小体力消耗路径 - 力扣（LeetCode）](https://leetcode.cn/problems/path-with-minimum-effort/description/)

## 带权并查集

（待更新）

### 模板

```python
root = list(range(n + 1))
vec = [0] * (n + 1)
height = [0] * (n + 1)


def find(x: int) -> int:
    if root[x] != x:
        rx = find(root[x])
        vec[x] += vec[root[x]]
        root[x] = rx
    return root[x]


def union(x: int, y: int, v: int):
    rx = find(x)
    ry = find(y)
    if rx != ry:
        if height[ry] >= height[rx]:
            root[rx] = ry
            vec[rx] = v + vec[y] - vec[x]
            height[ry] = max(height[ry], height[rx] + 1)
        else:
            root[ry] = rx
            vec[ry] = -v + vec[x] - vec[y]
```

## 树状数组

### 介绍

[树状数组：从入门到精通 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/574739597)：文章中的核心点——`tree[i]`中记录的是【**以`a[i]`为结尾、长度为`lowbit(i)`的区间的和，也就是`(i-lowbit(i), i]`这一区间的和**】

【树状数组】擅长处理--【数组中单点修改 + 区间和】 问题

### 模板

**方法**

- init：初始化
- add：i下标增加val
- query：前i个值的和（前缀和）

**关键点**：**tree[i+1]的值代表原nums中(i-lowBit(i),i]的区间和（左开右闭）**

- 时间 
  - 初始化：nlogn（优化前） 或 n （优化后）
  - add：logn
  - query：logn
- 空间 n

**时间优化：**初始化的n时间优化，有点类似于堆的初始化，可以一个个的push进去元素，总时间为nlogn，也可以进行高级的堆化操作，时间为n

**注意：**代码中注意 树状数组和nums原数字数组的下标（相差1），时刻明确自己在操作哪个数组，下标要写正确！

```go
type TreeArray struct {
	tree []int
}

// NewTreeArray 初始化 (nlogn时间)
func NewTreeArray(nums []int) *TreeArray {
	n := len(nums)
	ta := &TreeArray{
		tree: make([]int, n+1), // 树状数组下标从1开始
	}
	for i, x := range nums {
		ta.Add(i+1, x) // 树状数组下标从1开始
	}
	return ta
}

// NewTreeArray 初始化 (n时间 优化版本）
func NewTreeArray(nums []int) *TreeArray {
	n := len(nums)
	ta := &TreeArray{
		tree: make([]int, n+1), // 树状数组下标从1开始
	}
	// 核心优化点 类似动态规划的「刷表法」
	for i, x := range nums {
		i++
		ta.tree[i] += x
		if nxt := i + lowBit(i); nxt < n+1 {
			ta.tree[nxt] += ta.tree[i]
		}
	}
	return ta
}

// x的最后一位1
func lowBit(x int) int {
	return x & -x
}

// Add (从树状数组第i项开始往后更新）nums中i-1位置的值增加val
func (ta *TreeArray) Add(i int, val int) {
	for ; i < len(ta.tree); i += lowBit(i) {
		ta.tree[i] += val
	}
}

// Query 树状数组中前i（包含）项的和 （前缀和）
func (ta *TreeArray) Query(i int) int {
	sum := 0
	for ; i > 0; i -= lowBit(i) {
		sum += ta.tree[i]
	}
	return sum
}

// SumRange nums[left,right]的和 （左闭右闭）
func (ta *TreeArray) SumRange(left int, right int) int {
	return ta.Query(right+1) - ta.Query(left)
}
```

**注意：**树状数组中没有一个很完善可兼容各题型场景的模板，理解核心思路后，在碰到题需要用到时，可结合核心点+题意灵活的去运用

### 思路拓展

（参考自宫水三叶姐）

针对不同的题目，我们有不同的方案可以选择（假设我们有一个数组）：

- 数组不变，求区间和：「前缀和」、「树状数组」、「线段树」
- 多次修改某个数（单点），求区间和：「树状数组」、「线段树」
- 多次修改某个区间，输出最终结果：「差分」
- 多次修改某个区间，求区间和：「线段树」、「树状数组」（看修改区间范围大小）
- 多次将某个区间变成同一个数，求区间和：「线段树」、「树状数组」（看修改区间范围大小）

这样看来，「线段树」能解决的问题是最多的，那我们是不是无论什么情况都写「线段树」呢？

答案并不是，而且恰好相反，只有在我们遇到第 4 类问题，不得不写「线段树」的时候，我们才考虑线段树。

因为「线段树」代码很长，而且常数很大，实际表现不算很好。我们只有在不得不用的时候才考虑「线段树」。



总结一下，我们应该按这样的优先级进行考虑：

- 简单求区间和，用「前缀和」
- 多次将某个区间变成同一个数，用「线段树」
- 其他情况，用「树状数组」

[307. 区域和检索 - 数组可修改 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-mutable/description/)

## 线段树

待学习补充）

[307. 区域和检索 - 数组可修改 - 力扣（LeetCode）](https://leetcode.cn/problems/range-sum-query-mutable/description/)

# 进阶算法

## 快速选择

**适用场景**：在O(n)的时间内找到数组arr中第k小/大的数（TopK）

**思路**：本质类同快排的分治思想。（以第k小为例）随机取数组内一数num，遍历数组，小于num放左侧，大于num放右侧。

设放完后num排在第rk个位置

- rk=k则说明当前num恰为第k小
- rk>k则说明num大于Topk，需继续在左区间内找
- rk<k则说明num小于Topk，需继续在右区间内找



**golang模板**

实际代码采用了很巧妙的双指针技巧，详见代码、注释和网上大神们的博客~

- 时间 n
- 空间 1

```go
import "math/rand"

// 第k大
func quickSelectTopK(arr []int, start, end, k int) int { //start end 左闭右开
	partition := rand.Int()%(end-start) + start             // 中间的分区数
	arr[start], arr[partition] = arr[partition], arr[start] // 分区数 挪至最左侧

	pivot := arr[start]                // 分区数
	idx := start                       // >= 分区数pivot 的最后一位下标
	for j := start + 1; j < end; j++ { // 遍历 区分/找大于和小于pivot的数
		if arr[j] >= pivot {
			arr[idx+1], arr[j] = arr[j], arr[idx+1] // idx+1为<pivot的数下标，将>=pivot的数 挪至左侧
			idx++
		}
	}

	//调换分区数至中间
	arr[idx], arr[start] = arr[start], arr[idx]

	//当前pivot排Top几
	rk := idx - start + 1

	if k < rk {
		return quickSelectTopK(arr, start, idx, k)
	} else if k == rk {
		return arr[idx]
	} else {
		return quickSelectTopK(arr, idx+1, end, k-rk)
	}
}

```

[2583. 二叉树中的第 K 大层和 - 力扣（LeetCode）](https://leetcode.cn/problems/kth-largest-sum-in-a-binary-tree/description/)

# 数学 

## 通用

[189. 轮转数组 - 力扣（LeetCode）](https://leetcode.cn/problems/rotate-array/description/?envType=study-plan-v2&envId=top-100-liked)

[100153. 需要添加的硬币的最小数量 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-coins-to-be-added/solutions/2552290/100153-xu-yao-tian-jia-de-ying-bi-de-zui-keuc/)

[100151. 使数组成为等数数组的最小代价 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-cost-to-make-array-equalindromic/description/)

[100225. 求交集区域内的最大正方形面积 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-largest-area-of-square-inside-two-rectangles/description/)

## 矩阵

涉及矩阵相关，其实就是二维数组感觉）

[73. 矩阵置零 - 力扣（LeetCode）](https://leetcode.cn/problems/set-matrix-zeroes/description/)

[54. 螺旋矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix/description/)

## 除数/余数

涉及除法、余数等数学计算

一般通过简单的数学计算和推导公式得到一个解题思路

$(a*b)\%mod = (a\%mod * b\%mod)\%mod$  

在取余数的算式中，任何地方加mod后不影响最后结果，为避免数值溢出，通常在算式各处加上mod

[100097. 合法分组的最少组数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/description/)

[2575. 找出字符串的可整除数组 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-divisibility-array-of-a-string/description/?envType=daily-question&envId=2024-03-07)

## 最大公约数

gcd

**辗转相除法**

- 时间 $log(max(a,b))$
- 空间 $1$

```go
func gcd(a, b int) int {
    // 辗转相除
    for a != 0 {
        a, b = b%a, a
    }
    return b
}
```

[2807. 在链表中插入最大公约数 - 力扣（LeetCode）](https://leetcode.cn/problems/insert-greatest-common-divisors-in-linked-list/description/)

## 最小公倍数

LCM（least common multiple）

最小公倍数=两整数的乘积÷最大公约数

- 时间 $log(max(a,b))$
- 空间 $1$

```go
func lcm(a, b int) int {
	return a * b / gcd(a, b)
}
```

## 容斥原理

介绍：[容斥原理 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)

![image-20231017111431161](https://s2.loli.net/2023/10/17/4Wg9qZBNOcSPIox.png)

[2652. 倍数求和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-multiples/description/)

[100127. 给小朋友们分糖果 II - 力扣（LeetCode）](https://leetcode.cn/problems/distribute-candies-among-children-ii/description/)

[100126. 重新排列后包含指定子字符串的字符串数目 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-strings-which-can-be-rearranged-to-contain-substring/description/)

## 等比/等差数列

- 等差数列通项公式：An = $a1 + (n - 1) * d$
- 等差数列求和公式: SumAn = $(a1 + an) * n / 2$
- 等比数列通项公式: Sn = $a1 * q ^ (n - 1)$
- 等比数列求和公式：SumSn = $a1 * (1 - q ^ n) / (1 - q)$
  - ![等比数列求和公式图册_360百科](https://so1.360tres.com/t01c6077c104c1ecfa6.jpg)

[2652. 倍数求和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-multiples/description/)

[2656. K 个元素的最大和 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-sum-with-exactly-k-elements/description/)

## 组合

几个数 组合在一起酱紫

[1726. 同积元组 - 力扣（LeetCode）](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)

## 快速幂

### 原理（递归版）

经典的分治思想，每次只算一半即可，一半乘一半得最终

需要特判考虑一些奇数情况，一半乘一半后还得+1

### 模板（递归版）

$mod$为取余数，根据题意可有可无

- 时间 logn
- 空间 logn

```go
func pow(x int, n int) int {
	if n == 0 {
		return 1
	}

	res := 1
	half := pow(x, n/2)
	if n%2 == 1 { // 奇数额外乘1个x
		res = x % mod
	}
	return res * half * half % mod
}
```

### 原理（迭代版）

求$x^n$

从二进制来分析$n$这个数，可发现$n$转为二进制后，只要我们$res$从$1$开始，对于$n$二进制中的每个$1$，$res *= x^{m}$即可（$m = 1<<idx $ ，$idx$为从右往左数对应$1$的位置长度）

可从$n$的二进制低位开始位运算遍历，期间维护$x$的大小（避免重复计算），碰到1时乘一下即可

### 模板（迭代版）

$mod$为取余数，根据题意可有可无

- 时间 logn
- 空间 1

```go
func pow(x, n int) int {
	res := 1
	for ; n > 0; n /= 2 {
		if n%2 > 0 {
			res = res * x % mod
		}
		x = x * x % mod
	}
	return res
}
```

[50. Pow(x, n) - 力扣（LeetCode）](https://leetcode.cn/problems/powx-n/description/)

[100155. 双模幂运算 - 力扣（LeetCode）](https://leetcode.cn/problems/double-modular-exponentiation/description/)

## 回文数

### 计算n范围所有回文数

按从小到大顺序，$\sqrt{n}$ 时间快速求出n范围的所有的回文数，并存储至数组。

**原理**：通过枚举回文数的左半部分得到。

**时间**：$\sqrt{n}$

```go
// 以下为求1e9范围内所有回文数，自行使用时需根据题目所需修改一些常数

// 回文数数组
var pal = make([]int, 0, 109998) // 这里的109998是打表时提前知道了1e9内回文数的数目

// 初始化 回文数数组
func init() {
	//按从小到大顺序求回文数数组
	for base := 1; base <= 1e4; base *= 10 {
		//奇数长度 回文数
		for b := base; b < base*10; b++ {
			palNum := b
			for tmp := b / 10; tmp > 0; tmp /= 10 {
				palNum = palNum*10 + tmp%10
			}
			pal = append(pal, palNum)
		}
		//偶数长度 回文数
		if base <= 1e3 {
			for b := base; b < base*10; b++ {
				palNum := b
				for tmp := b; tmp > 0; tmp /= 10 {
					palNum = palNum*10 + tmp%10
				}
				pal = append(pal, palNum)
			}
		}
	}
}
```

### 判断回文数

假设此时数为int类型

- **方法1**：转string后，双指针一前一后往中间走判断
- **方法2**：转string后，reverse一下，看和之前是否一样
- **方法3**：先求出int长度L，然后通过取余%10找到最后一个，通过除法/L找到第一位，比较是否相同，接着以此类推

## 质数

### 质数判断

- 时间 $\sqrt{n}$

```go
func isPrime(n int) bool {
	for i := 2; i*i <= n; i++ {
		if n%i == 0 {
			return false
		}
	}
	return true
}
```

### 质数预处理生成

#### 埃氏筛

- 时间 `nloglogn`

golang

```go
const mx = 1e3 + 1 // 范围
var (
	primes   []int    // 质数
	nonPrime [mx]bool // 非质数
)

func init() {
	for num := 2; num < mx; num++ {
		if !nonPrime[num] {
			primes = append(primes, num)
			for i := num * num; i < mx; i += num {
				nonPrime[i] = true
			}
		}
	}
}
```

python

```python
# 埃氏筛
MX = 10 ** 3
primes = []
is_prime = [True] * (MX + 1)
for num in range(2, MX + 1):
    if is_prime[num]:
        primes.append(num)
        for i in range(num ** 2, MX + 1, num):
            is_prime[i] = False
```

#### 线性筛

- 时间 n

golang

```go
const mx = 1e3 + 1 // 范围
var (
	primes   []int    // 质数
	nonPrime [mx]bool // 非质数
)

func init() {
	for num := 2; num < mx; num++ {
		if !nonPrime[num] {
			primes = append(primes, num)
		}
		for _, p := range primes {
			if num*p >= mx {
				break
			}
			nonPrime[num*p] = true
			if num%p == 0 {
				break
			}
		}
	}
}
```

python

```python
# 线性筛
# 遍历 primes 中的 p，若p 小于等于x最小质因子，则划掉 x*p
MX = 10 ** 3
primes = []
is_prime = [True] * (MX + 1)
for num in range(2, MX + 1):
    if is_prime[num]:
        primes.append(num)
    for p in primes:
        if p == 0:
            continue
        if p * num > MX:
            break
        is_prime[p * num] = False
        if num % p == 0:
            break
```

## 乘法原理

做一件事，完成它需要分成$n$个步骤，做第一步有$m1$种不同的方法，做第二步有$m2$种不同的方法，……，做第$n$步有$m_n$种不同的方法。那么完成这件事共有 $N=m1×m2×m3×…×m_n$ 种不同的方法。 和[加法原理](https://baike.baidu.com/item/加法原理/7538330?fromModule=lemma_inlink)是数学概率方面的基本原理。

**实际使用-简单数学技巧**

给出一个数组$num$，求里面所有数两两组合的和，暴力是$n²$时间，我们可以从左到右遍历，维护截止至目前$sum$，所有的当前值$val$乘以$sum$的和即为答案~ 优化时间至$n$！

例如：$3 \ 4\  5$，$n²$为$（3 * 4 + 3 * 5 + 4 *5 ）$，优化后为 $（ 3 * 0 + 4 * 3 + 5 * 7 ）$

[100226. 在带权树网络中统计可连接服务器对数目 - 力扣（LeetCode）](https://leetcode.cn/problems/count-pairs-of-connectable-servers-in-a-weighted-tree-network/description/)

## 差分数组

[分享｜【算法小课堂】差分数组（Python/Java/C++/Go/JS） - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/FfMCgb/)

对 *a* 中连续子数组的操作，可以转变成对差分数组 *d* 中**两个数**的操作

差分数组擅长处理**「区间修改，单点查询」**的经典问题

![image-20230910165958567](https://s2.loli.net/2023/10/21/odfxmLGiXURCylt.png)

```go
// 给定一些区间操作，其中 queries[i] = [left, right, x]，
// 你需要把子数组 a[left], a[left+1], ... a[right] 都加上 x。
// 返回所有操作执行完后的数组 a。
func solve(n int, queries [][]int) []int {
    diff := make([]int, n) // 差分数组
    for _, q := range queries {
        left, right, x := q[0], q[1], q[2]
        diff[left] += x
        if right+1 < n {
            diff[right+1] -= x
        }
    }
    for i := 1; i < n; i++ {
        diff[i] += diff[i-1] // 直接在差分数组上复原数组 a
    }
    return diff
}
```

[1094. 拼车 - 力扣（LeetCode）](https://leetcode.cn/problems/car-pooling/description/?envType=daily-question&envId=2023-12-02)

## 离散化

例如：把最小元素映射为 1，次小元素映射为 2，依此类推。

# 思维题/脑筋急转弯

好像没有什么特别的切入点思路，比较灵活考察智商？hhh

看思维活不活跃，不要固化思维思路，敢于想象

[2731. 移动机器人 - 力扣（LeetCode）](https://leetcode.cn/problems/movement-of-robots/description/?envType=daily-question&envId=2023-10-10)

[237. 删除链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/delete-node-in-a-linked-list/description/)

[100164. 通过操作使数组长度最小 - 力扣（LeetCode）](https://leetcode.cn/problems/minimize-length-of-array-using-operations/description/)

[292. Nim 游戏 - 力扣（LeetCode）](https://leetcode.cn/problems/nim-game/description/)

# 设计

依题意，设计出所要求的类及各类操作，套路满满qwq

[1670. 设计前中后队列 - 力扣（LeetCode）](https://leetcode.cn/problems/design-front-middle-back-queue/description/)

[232. 用栈实现队列 - 力扣（LeetCode）](https://leetcode.cn/problems/implement-queue-using-stacks/description/)

# 技巧

## 分组循环

**适用场景**：按照题目要求，数组会被分割成若干组，且每一组的判断/处理逻辑是一样的。

**核心思想**：

- 外层循环负责遍历组之前的准备工作（记录开始位置），和遍历组之后的统计工作（更新答案最大值）。
- 内层循环负责遍历组，找出这一组在哪结束。

这个写法的好处是，各个逻辑块分工明确，也不需要特判最后一组（易错点）。以灵神的经验，这个写法是所有写法中最不容易出 bug 的，推荐大家记住。

**模板**

```go
n := len(nums)
for i := 0; i < n; {
    // 过滤不合适起点
    if xxx {
        i++
        continue
    }

    start := i // 记录起点
    for i++;i < n && ...;i++ {

    }

    // 此时从 start 到 i-1 是一组
    // 下一组从 i 开始，无需 i += 1
    ans = xxx
}
```

[2760. 最长奇偶子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/description/)

[100145. 统计完全子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/count-complete-substrings/)

[2982. 找出出现至少三次的最长特殊子字符串 II - 力扣（LeetCode）](https://leetcode.cn/problems/find-longest-special-substring-that-occurs-thrice-ii/description/)

[100199. 判断一个数组是否可以变为有序 - 力扣（LeetCode）](https://leetcode.cn/problems/find-if-array-can-be-sorted/description/)

## 向上取整

$num/size$ 想要实现向上取整

多种方式

- $(num+size-1)/size$
- $(num-1)/size + 1$

## 打表法

有些题目想要的答案数值的可能值列表，无论在什么情形下都是固定的时候，可自行在本机电脑上先算出所有可能值，放到数组中，后把所有可能值定义在全局变量中，后续需要的话在里面搜索即可 ovo

[2048. 下一个更大的数值平衡数 - 力扣（LeetCode）](https://leetcode.cn/problems/next-greater-numerically-balanced-number/description/?envType=daily-question&envId=2023-12-09)

## 二维数组循环（清晰结构）

$golang$在进行二维数组循环时，可采用两段$range$来写，这样最终操作时，既有$i、j$下标，也有$x$直接表示元素，想用哪个用哪个，避免繁琐的通过$i、j$下标组合来表示$x$，避免代码臃肿，简化逻辑思路

```go
for i, row := range mat {
    for j, x := range row {
        // xxx
    }
}
```

## 判断两字母是否为同一字母（不区分大小写）

因在$ASCII$码中 小写大写字母差距恰为$32$，所以$A$和$a$的$bit$中低$5$位（因为$2^5=32$）是相同的，其他字母类同

所以取低$5$位看是否相同，则可判断是否是同一字母

```go
// 不是同一字母
if char1&31 != char2&31 {
    // xxx
}

// 是同一字母
if char1&31 == char2&31 {
    // xxx
}
```

## 快速copy一个切片

**非调用copy函数版本**

copy函数还得自己提前make申请空间）

```go
// 方法1
numsTmp := append([]int(nil), nums...)

// 方法2
numsTmp := append([]int{}, nums...)
```

**调用copy函数版本**

```go
numTmp := make([]int, len(nums))
copy(numTmp, nums)
```

