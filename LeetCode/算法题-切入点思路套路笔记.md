# 脑筋急转弯

好像没有什么特别的切入点思路，比较灵活考察智商？hhh

看思维活不活跃，不要固化思维思路，敢于想象

[2731. 移动机器人 - 力扣（LeetCode）](https://leetcode.cn/problems/movement-of-robots/description/?envType=daily-question&envId=2023-10-10)

# 模拟

题目一般都说了一堆，但感觉按照它说的一步步做就可出答案，只是步骤繁多，但每一步都不是那么难

主要一个你说什么我就按什么做

[2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）](https://leetcode.cn/problems/reward-top-k-students/description/)

# 位运算

考虑状态压缩，减少时间和空间

二进制相关

涉及到 异或、与、或、非、左移<<、右移>> 等运算

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/description/)

[137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/description/?envType=daily-question&envId=2023-10-15)

[260. 只出现一次的数字 III - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-iii/description/)

## **技巧**

灵神总结：[分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/CaOJ45/)

### lowbit

找到某个数的二进制最低位的1

```go
     s = 101100
    ~s = 010011
(~s)+1 = 010100 // 根据补码的定义，这就是 -s   最低 1 左侧取反，右侧不变
s & -s = 000100 // lowbit
```

# 滑动窗口

某些区间/区间值是固定的，通过双指针可滑动维护区间长度/区间值等

涉及双指针的思想

[100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/)

# 双指针

一个指针不够指就上两个 ovo

同时维护多个指针变量

涉及两个数在变化，可用两个指针指着这两个变化的东西，从而进行后续的判断等操作

# 哈希表

**核心观念：**空间换时间

已经算过/遍历过的数存起来，后面再用到时直接上哈希表里根据key取

如果后面的数需要用到前面的东西，而返回去再看前面东西时费劲，就可考虑哈希表

[1726. 同积元组 - 力扣（LeetCode）](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)

# 前后缀分解

如题意所示，将前缀和后缀分解求解，随后再组合在一起

[8026. 构造乘积矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-product-matrix/description/)

# 高级数据结构

## 堆/优先队列

根据heap接口自行构造实现

```go
type Interface interface {
	sort.Interface
	Push(x any) // add x as element Len()
	Pop() any   // remove and return element Len() - 1.
}
```

例如：最大堆

(这里push和pop没有去实现只整了个空函数，是因为在解某个题时没用到。。用了默认的Fix函数)

```go
type hp struct{ sort.IntSlice }

func (h hp) Less(i, j int) bool { return h.IntSlice[i] > h.IntSlice[j] } //最大堆
func (hp) Push(_ any)           {}
func (hp) Pop() (_ any)         { return }
```

[2530. 执行 K 次操作后的最大分数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-score-after-applying-k-operations/description/)

# 数学

## 容斥原理

介绍：[容斥原理 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)

![image-20231017111431161](https://s2.loli.net/2023/10/17/4Wg9qZBNOcSPIox.png)

[2652. 倍数求和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-multiples/description/)

## 等比/等差数列

- 等差数列通项公式：An = a1 + (n - 1) * d
- 等差数列求和公式: SumAn = (a1 + an) * n / 2
- 等比数列通项公式: Sn = a1 * q ^ (n - 1)
- 等比数列求和公式：SumSn = a1 * (1 - q ^ n) / (1 - q)
  - ![等比数列求和公式图册_360百科](https://so1.360tres.com/t01c6077c104c1ecfa6.jpg)

[2652. 倍数求和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-multiples/description/)

## 组合

几个数 组合在一起酱紫

[1726. 同积元组 - 力扣（LeetCode）](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)