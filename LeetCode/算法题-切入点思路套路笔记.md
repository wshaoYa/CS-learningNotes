# 哈希表

**核心观念：**空间换时间

已经算过/遍历过的数存起来，后面再用到时直接上哈希表里根据key取

如果后面的数需要用到前面的东西，而返回去再看前面东西时费劲，就可考虑哈希表

[1726. 同积元组 - 力扣（LeetCode）](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)

# 模拟

题目一般都说了一堆，但感觉按照它说的一步步做就可出答案，只是步骤繁多，但每一步都不是那么难

主要一个你说什么我就按什么做

[2512. 奖励最顶尖的 K 名学生 - 力扣（LeetCode）](https://leetcode.cn/problems/reward-top-k-students/description/)

[2525. 根据规则将箱子分类 - 力扣（LeetCode）](https://leetcode.cn/problems/categorize-box-according-to-criteria/description/)

# 枚举

略微有点暴力思想

根据题意，在允许的时间复杂度情况下，枚举所有可能答案，维护最佳答案

[100097. 合法分组的最少组数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/description/)

# 滑动窗口

某些区间/区间值是固定的，通过双指针可滑动维护区间长度/区间值等

涉及双指针的思想

[100084. 最短且字典序最小的美丽子字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/shortest-and-lexicographically-smallest-beautiful-string/description/)

[438. 找到字符串中所有字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/)

# 双指针

一个指针不够指就上两个 ovo

同时维护多个指针变量

涉及两个数在变化，可用两个指针指着这两个变化的东西，从而进行后续的判断等操作

# 排序

一些值的大小关系顺序很重要，拿到有序的数后能结合贪心等其他思想很好的解决问题，考虑排序

[1402. 做菜顺序 - 力扣（LeetCode）](https://leetcode.cn/problems/reducing-dishes/description/)

# 二分

**灵神讲解：**

- [二分查找 红蓝染色法_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1AP41137w7/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)
- [搜索旋转排序数组【基础算法精讲 05】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1QK411d76w/?spm_id_from=333.788&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

**前提：**有序 或 具有单调性

可left、right手搓二分（细节把控更好，理解更深刻）

也可直接调用语言的默认二分函数（省时省力高效）

[275. H 指数 II - 力扣（LeetCode）](https://leetcode.cn/problems/h-index-ii/description/?envType=daily-question&envId=2023-10-30)

# 前缀和

涉及连续子数组问题，可用**前缀和 + 哈希表**来快速判断某子数组是否存在/满足题意要求

[560. 和为 K 的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/subarray-sum-equals-k/description/)

# 前后缀分解

如题意所示，将前缀和后缀分别求解，随后再组合在一起

涉及三元组

涉及到前缀和后缀的情况，可将前缀和后缀分开进行分别考虑，逐个击破求解，最后再合一起

[8026. 构造乘积矩阵 - 力扣（LeetCode）](https://leetcode.cn/problems/construct-product-matrix/description/)

[100114. 元素和最小的山形三元组 II - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-sum-of-mountain-triplets-ii/description/)

# 回溯

一般数据范围较小，可通过暴力枚举等方式计算出答案（但普通的for形式又行不通），可考虑暴力回溯，一般用dfs递归实现

要特别注意正确定义dfs中的参数，否则思路将阻塞尬住

一些难以一眼理解的函数（例如dfs）等，可简单注释下含义，方便code和理解

[2698. 求一个整数的惩罚数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/description/)

# 贪心

感觉题目有一些贪心巧妙的方式应该存在，按照我这种贪心的方式就能很好的避免暴力

为了省事省空间时间，从题面整个大的角度去思考问题，直接思考有没有巧妙且贪心的思路酱紫

[1402. 做菜顺序 - 力扣（LeetCode）](https://leetcode.cn/problems/reducing-dishes/description/)

[1465. 切割后面积最大的蛋糕 - 力扣（LeetCode）](https://leetcode.cn/problems/maximum-area-of-a-piece-of-cake-after-horizontal-and-vertical-cuts/description/)

# 图

## 最小生成树（MST）

### 基本思想

​		n-1条边连通n个点，且总权重最小。

### 切分定理

​		对于两个已连通的点集合，其之间相连的最小边必为整个图最小生成树的一边。

### 常用方法

- **Kruskal（克鲁斯卡尔）：**
  - 取出所有的边，从小到大排序，每次取最小的，若构成环则跳过（利用并查集思想，判断两点是否一个连通分量，如果不是的话union连接此边的两点即可），取n-1条边后结束。
  - 时间 O(ElogE) （E为边数，排序需ElogE复杂度）
  - 空间 O(V)  （V为点数）
- **prim（普里姆）：**
  - 先随机取一点，并维护两个数组：①lowCost 已选取点集合到其他点的最短距离 ②visited 点是否被访问过。不断从visited为false中选出lowCost最小的，直至选出n-1条边结束。
  - lowCost一般用最小堆辅助优化，visited有些情况也可不用，直接lowCost也能代替。
  - 时间  O(ElogV)  （emm，暂时没搞懂为啥）
  - 空间  O(V)

## 单源最短路径

### 基本思想

​		图中，一个点到另外所有点的最短距离

### 常用方法

- **Dijkstra（迪杰斯特拉）**:
  - 维护lowDist数组和visited，记录各点到起点的最短距离，每次选取一个到起点最短的（最小堆辅助），并更新lowDist，直至遍历完成，思路类似于prim有些。只不过这里的lowDist是各点到**起点**的最短距离。
  - 只针对权重非负的，否则贪心思想无法保证下一步选择的路径是最佳的路径（因为负权重的存在
  - 时间 O(E+VlogV)  
  - 空间 O（V）
- **Bellman-Ford**：
  - 运用dp思想， 待补充 = =
- **优化的Bellman-Ford  ——SPFA**：
  - 维护lowDist数组，记录各点到起点的最短距离，维护Queue队列，每次从队列中取点遍历其边，更新lowDist，若更新则插入队列，另需visited数组记录此点是否已在队列中，防止重复插入队列。队列为空则结束。
  - 时间O(V*E)
  - 空间O(V)

## 拓扑排序

### 基本思想

​		图中，某节点进行需入度所有节点均已完成，基于节点进行顺序所排列的一种顺序成为拓扑排序。（关键路径/先修课 思想）

​		只针对于DAG（有向无环图）

### 常见方法

- Kahn算法
  - 维护一个Queue队列和各节点入度，将入度为0节点入队，出队时更新其所指节点的入度-1，为0则插入队列，直至结束。
  - 时间 O(V+E)
  - 空间 O(V+E)

# 记忆化搜索

**递归搜索 + 保存计算结果 = 记忆化搜索**

递归过程中出现重复计算的值，可用额外的哈希表/数组空间存储起来避免重复计算

一般记忆化搜索均能1:1翻译为递推

**启发思路：**

- 选 或 不选
- 枚举选哪个

![image-20231029173156759](https://s2.loli.net/2023/10/29/fLMcOZvnPmVdKgQ.png)

**思考步骤：**

![image-20231029173008419](https://s2.loli.net/2023/10/29/gSZiDKCj79EAINc.png)

**与dp区别：**

- 自顶向下算 = 记忆化搜索
- 自底向上算 = 递推dp

[100107. 使数组变美的最小增量运算数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/description/)

# 动态规划

普通的算法思路难以着手解决，中间**涉及到许多可能重复计算的方法/值**（一般一眼看上去题目思路无法模拟，较为繁琐多变）

定义状态，用状态给存储进来中间某阶段的值，并根据状态转移方程能计算出所有状态，根据最终的状态可求答案

## **灵感启发**

- 选 或 不选
- 枚举选哪个

![image-20231029173156759](https://s2.loli.net/2023/10/29/fLMcOZvnPmVdKgQ.png)

## **与记忆化搜索区别**

- 自顶向下算 = 记忆化搜索
- 自底向上算 = 递推dp

## **思考步骤**

![image-20231029173008419](https://s2.loli.net/2023/10/29/gSZiDKCj79EAINc.png)

## **大致步骤**

- 定义状态
- 根据定义的状态写出状态转移方程（发现不好写时，可能是自己的状态定义的有问题，可再读题思考状态定义，或考虑状态升维！）
- 递推计算出所有状态，求解答案

一般这类题目均可由【递归+记忆化搜索】解决，而【递归+记忆化搜索】均可递推转为dp，dp效率会略高

## 背包问题（套路）

[0-1背包 完全背包【基础算法精讲 18】_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV16Y411v7Y6/?p=18&spm_id_from=pageDriver&vd_source=10527fd74695c7dd4ae2589a62aa5f89)

![image-20231030121554991](https://s2.loli.net/2023/10/30/9oFmNYDezwCavLK.png)

### 0-1背包

![image-20231030121646656](https://s2.loli.net/2023/10/30/K7CrTwxoWLS9lIQ.png)

#### 常见变形

##### 至多装capacity



##### 恰好装capacity

![image-20231030121909729](https://s2.loli.net/2023/10/30/qVYfeDzdlha8Qg6.png)

最大/最小价值和类似，dfs的+改为min或max即可

##### 至少装capacity

#### 空间优化

##### 滚动数组

![image-20231030122117463](https://s2.loli.net/2023/10/30/km1o4EKZyQPurLq.png)

##### 单个数组

正序不行时，考虑倒序

![image-20231030122246912](https://s2.loli.net/2023/10/30/cgnrS1JXBiW3keA.png)

### 完全背包

![image-20231030122358492](https://s2.loli.net/2023/10/30/yiKP472RAmMFNV5.png)

#### 常见变形

##### 至多装capacity



##### 恰好装capacity

![image-20231030122521551](https://s2.loli.net/2023/10/30/n1KZEPBuJWQUvSs.png)

- 最大价值和：dfs min改为max即可

- 求方案数：min改为两个dfs+即可

##### 至少装capacity

#### 空间优化

类同于0-1背包里所述方法

## 练习题

[1155. 掷骰子等于目标和的方法数 - 力扣（LeetCode）](https://leetcode.cn/problems/number-of-dice-rolls-with-target-sum/description/)

[100107. 使数组变美的最小增量运算数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-increment-operations-to-make-array-beautiful/description/)

# 位运算

考虑状态压缩，减少时间和空间

二进制相关

涉及到 异或、与、或、非、左移<<、右移>> 等运算

[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/description/)

[137. 只出现一次的数字 II - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-ii/description/?envType=daily-question&envId=2023-10-15)

[260. 只出现一次的数字 III - 力扣（LeetCode）](https://leetcode.cn/problems/single-number-iii/description/)

## **技巧**

灵神总结：[分享｜从集合论到位运算，常见位运算技巧分类总结！ - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/CaOJ45/)

### lowbit

找到某个数的二进制最低位的1

```go
     s = 101100
    ~s = 010011
(~s)+1 = 010100 // 根据补码的定义，这就是 -s   最低 1 左侧取反，右侧不变
s & -s = 000100 // lowbit
```

# 高级数据结构

## 堆/优先队列

涉及到快速取某组数中的最大/最小值时，可考虑堆

### 模板

根据heap接口自行构造实现

```go
type Interface interface {
	sort.Interface
	Push(x any) // add x as element Len()
	Pop() any   // remove and return element Len() - 1.
}
```

Golang中自己构造heap时，$sort.IntSlice$ 很方便的帮我们解决了$Len$、$Swap$、和$Less$函数，只不过它默认用的$Less$不符合我们最大堆，如果想要最小堆的话就不用自己再重写一遍$Less$了

```go
// IntSlice attaches the methods of Interface to []int, sorting in increasing order.
type IntSlice []int

func (x IntSlice) Len() int           { return len(x) }
func (x IntSlice) Less(i, j int) bool { return x[i] < x[j] }
func (x IntSlice) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
```

**示例：最大堆**

(这里push和pop没有去实现只整了个空函数，是因为在解某个题时没用到。。用了默认的Fix函数)

```go
type hp struct{ sort.IntSlice }

func (h hp) Less(i, j int) bool { return h.IntSlice[i] > h.IntSlice[j] } //最大堆。如果想要最小堆则无需重写Less
func (hp) Push(_ any)           {}
func (hp) Pop() (_ any)         { return }

h = &hp{nums} // 初始化结构体（nums为切片类型）
heap.Init(h) // 堆化
heap.Fix(h, 0) // 改变堆顶元素后调用Fix，相当于pop & push
```

[2530. 执行 K 次操作后的最大分数 - 力扣（LeetCode）](https://leetcode.cn/problems/maximal-score-after-applying-k-operations/description/)

[2558. 从数量最多的堆取走礼物 - 力扣（LeetCode）](https://leetcode.cn/problems/take-gifts-from-the-richest-pile/description/)

## 并查集

### **基本思想**

​		通常用于解决图中连通、连通分量问题，通过find找到节点的父节点，union连接两节点来实现

- **find路径压缩优化**：
  - 调用find找到x的根节点后，将递归遍历过程中的各个节点的root[x]父节点值改为根节点，下次再find时更快
- **union按秩合并优化**：
  - 不合适的union会导致最终树/图变成一条链，效率低。记录各节点的高度，合并时将根节点高度高的根节点变为高度低的根节点的父节点即可（简单来说就是，低树的根节点挂到高树根节点的下边）。这样整个树有点avl那味，不至于最终树变为一条链。

### 模板

```go
type UnionFind struct {
	root    []int
	heights []int
}

// 初始化对象
func NewUnionFind(n int) *UnionFind {
	root := make([]int, n)
	heights := make([]int, n)
	for i := 0; i < n; i++ {
		root[i] = i
		heights[i] = 1
	}
	return &UnionFind{
		root:    root,
		heights: heights,
	}
}

// 路径压缩
func (uf *UnionFind) Find(node int) int {
	if uf.root[node] != node {
		uf.root[node] = uf.Find(uf.root[node])
	}
	return uf.root[node]
}

// 按秩优化
func (uf *UnionFind) Union(x, y int) {
	rx, ry := uf.Find(x), uf.Find(y)
	if rx == ry {
		return
	}

	if uf.heights[rx] >= uf.heights[ry] {
		uf.root[ry] = rx
		uf.heights[rx] = max(uf.heights[rx], uf.heights[ry]+1)
	} else {
		uf.root[rx] = ry
	}
}
```

### 复杂度

![image-20220804173128448](https://s2.loli.net/2023/10/21/ixEpulHzXbF6VsK.png)

- 空间复杂度：O(n)

## 带权并查集

（待更新）

### 模板

```python
root = list(range(n + 1))
vec = [0] * (n + 1)
height = [0] * (n + 1)


def find(x: int) -> int:
    if root[x] != x:
        rx = find(root[x])
        vec[x] += vec[root[x]]
        root[x] = rx
    return root[x]


def union(x: int, y: int, v: int):
    rx = find(x)
    ry = find(y)
    if rx != ry:
        if height[ry] >= height[rx]:
            root[rx] = ry
            vec[rx] = v + vec[y] - vec[x]
            height[ry] = max(height[ry], height[rx] + 1)
        else:
            root[ry] = rx
            vec[ry] = -v + vec[x] - vec[y]
```

# 数学

## 除数/余数

涉及除法、余数等数学计算

一般通过简单的数学计算和推导公式得到一个解题思路

[100097. 合法分组的最少组数 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-number-of-groups-to-create-a-valid-assignment/description/)

## 容斥原理

介绍：[容斥原理 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/combinatorics/inclusion-exclusion-principle/)

![image-20231017111431161](https://s2.loli.net/2023/10/17/4Wg9qZBNOcSPIox.png)

[2652. 倍数求和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-multiples/description/)

## 等比/等差数列

- 等差数列通项公式：An = a1 + (n - 1) * d
- 等差数列求和公式: SumAn = (a1 + an) * n / 2
- 等比数列通项公式: Sn = a1 * q ^ (n - 1)
- 等比数列求和公式：SumSn = a1 * (1 - q ^ n) / (1 - q)
  - ![等比数列求和公式图册_360百科](https://so1.360tres.com/t01c6077c104c1ecfa6.jpg)

[2652. 倍数求和 - 力扣（LeetCode）](https://leetcode.cn/problems/sum-multiples/description/)

## 组合

几个数 组合在一起酱紫

[1726. 同积元组 - 力扣（LeetCode）](https://leetcode.cn/problems/tuple-with-same-product/description/?envType=daily-question&envId=2023-10-19)

## 质数生成

### 埃氏筛

```python
# 埃氏筛
MX = 10 ** 3
primes = [0]
is_prime = [True] * (MX + 1)
for num in range(2, MX + 1):
    if is_prime[num]:
        primes.append(num)
        for i in range(num ** 2, MX + 1, num):
            is_prime[i] = False
```

### 线性筛

```python
# 线性筛
# 遍历 primes 中的 p，若p 小于等于x最小质因子，则划掉 x*p
MX = 10 ** 3
primes = [0]
is_prime = [True] * (MX + 1)
for num in range(2, MX + 1):
    if is_prime[num]:
        primes.append(num)
    for p in primes:
        if p == 0:
            continue
        if p * num > MX:
            break
        is_prime[p * num] = False
        if num % p == 0:
            break
```

## 差分数组

[分享｜【算法小课堂】差分数组（Python/Java/C++/Go/JS） - 力扣（LeetCode）](https://leetcode.cn/circle/discuss/FfMCgb/)

对 *a* 中连续子数组的操作，可以转变成对差分数组 *d* 中**两个数**的操作

![image-20230910165958567](https://s2.loli.net/2023/10/21/odfxmLGiXURCylt.png)

```go
// 给定一些区间操作，其中 queries[i] = [left, right, x]，
// 你需要把子数组 a[left], a[left+1], ... a[right] 都加上 x。
// 返回所有操作执行完后的数组 a。
func solve(n int, queries [][]int) []int {
    diff := make([]int, n) // 差分数组
    for _, q := range queries {
        left, right, x := q[0], q[1], q[2]
        diff[left] += x
        if right+1 < n {
            diff[right+1] -= x
        }
    }
    for i := 1; i < n; i++ {
        diff[i] += diff[i-1] // 直接在差分数组上复原数组 a
    }
    return diff
}
```

# 脑筋急转弯

好像没有什么特别的切入点思路，比较灵活考察智商？hhh

看思维活不活跃，不要固化思维思路，敢于想象

[2731. 移动机器人 - 力扣（LeetCode）](https://leetcode.cn/problems/movement-of-robots/description/?envType=daily-question&envId=2023-10-10)

# 